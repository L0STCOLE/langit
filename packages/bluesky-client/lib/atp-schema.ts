// This file is automatically generated, do not edit!
// Run scripts/generate-atp-schema.js to update this file.

export type CID = string;

export type DID = `did:${string}`;

export type Handle = string;

export type AtUri = string;

export type AtIdentifier = AtUri | Handle;

export interface AtBlob<T extends string = string> {
	$type: 'blob';
	mimeType: T;
	ref: {
		$link: string;
	};
	size: number;
}

export type ResponseOf<K extends keyof Queries | keyof Procedures> = K extends keyof Queries
	? Queries[K] extends { response: any }
		? Queries[K]['response']
		: unknown
	: K extends keyof Procedures
		? Procedures[K] extends { response: any }
			? Procedures[K]['response']
			: unknown
		: never;

export type RefOf<K extends keyof Objects> = Objects[K];
export type UnionOf<K extends keyof Objects> = Objects[K] & { $type: K };

export interface Queries {
	/**
	 * Get private preferences attached to the account.
	 */
	'app.bsky.actor.getPreferences': {
		response: {
			preferences: RefOf<'app.bsky.actor.defs#preferences'>;
		};
	};
	/**
	 * Get detailed profile view of an actor.
	 */
	'app.bsky.actor.getProfile': {
		params: {
			actor: string;
		};
		response: RefOf<'app.bsky.actor.defs#profileViewDetailed'>;
	};
	/**
	 * Get detailed profile views of multiple actors.
	 */
	'app.bsky.actor.getProfiles': {
		params: {
			/**
			 * Maximum array length: 25
			 */
			actors: string[];
		};
		response: {
			profiles: RefOf<'app.bsky.actor.defs#profileViewDetailed'>[];
		};
	};
	/**
	 * Get a list of suggested actors, used for discovery.
	 */
	'app.bsky.actor.getSuggestions': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			actors: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Find actors (profiles) matching search criteria.
	 */
	'app.bsky.actor.searchActors': {
		params: {
			/**
			 * DEPRECATED: use 'q' instead.
			 * @deprecated
			 */
			term?: string;
			/**
			 * Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended.
			 */
			q?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			actors: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Find actor suggestions for a prefix search term.
	 */
	'app.bsky.actor.searchActorsTypeahead': {
		params: {
			/**
			 * DEPRECATED: use 'q' instead.
			 * @deprecated
			 */
			term?: string;
			/**
			 * Search query prefix; not a full query string.
			 */
			q?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 10
			 */
			limit?: number;
		};
		response: {
			actors: RefOf<'app.bsky.actor.defs#profileViewBasic'>[];
		};
	};
	/**
	 * Get information about a feed generator, including policies and offered feed URIs.
	 */
	'app.bsky.feed.describeFeedGenerator': {
		response: {
			did: DID;
			feeds: RefOf<'app.bsky.feed.describeFeedGenerator#feed'>[];
			links?: RefOf<'app.bsky.feed.describeFeedGenerator#links'>;
		};
	};
	/**
	 * Get a list of feeds created by the actor.
	 */
	'app.bsky.feed.getActorFeeds': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * Get a list of posts liked by an actor.
	 */
	'app.bsky.feed.getActorLikes': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			BlockedActor: {};
			BlockedByActor: {};
		};
	};
	/**
	 * Get a view of an actor's feed.
	 */
	'app.bsky.feed.getAuthorFeed': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			/**
			 * @default "posts_with_replies"
			 */
			filter?:
				| 'posts_with_replies'
				| 'posts_no_replies'
				| 'posts_with_media'
				| 'posts_and_author_threads'
				| (string & {});
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			BlockedActor: {};
			BlockedByActor: {};
		};
	};
	/**
	 * Get a hydrated feed from an actor's selected feed generator.
	 */
	'app.bsky.feed.getFeed': {
		params: {
			feed: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			UnknownFeed: {};
		};
	};
	/**
	 * Get information about a feed generator.
	 */
	'app.bsky.feed.getFeedGenerator': {
		params: {
			feed: AtUri;
		};
		response: {
			view: RefOf<'app.bsky.feed.defs#generatorView'>;
			isOnline: boolean;
			isValid: boolean;
		};
	};
	/**
	 * Get information about a list of feed generators.
	 */
	'app.bsky.feed.getFeedGenerators': {
		params: {
			feeds: AtUri[];
		};
		response: {
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * Get a skeleton of a feed provided by a feed generator.
	 */
	'app.bsky.feed.getFeedSkeleton': {
		params: {
			feed: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#skeletonFeedPost'>[];
		};
		errors: {
			UnknownFeed: {};
		};
	};
	/**
	 * Get the list of likes.
	 */
	'app.bsky.feed.getLikes': {
		params: {
			uri: AtUri;
			cid?: CID;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			uri: AtUri;
			cid?: CID;
			cursor?: string;
			likes: RefOf<'app.bsky.feed.getLikes#like'>[];
		};
	};
	/**
	 * Get a view of a recent posts from actors in a list.
	 */
	'app.bsky.feed.getListFeed': {
		params: {
			list: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			UnknownList: {};
		};
	};
	/**
	 * Get posts in a thread.
	 */
	'app.bsky.feed.getPostThread': {
		params: {
			uri: AtUri;
			/**
			 * Minimum: 0 \
			 * Maximum: 1000
			 * @default 6
			 */
			depth?: number;
			/**
			 * Minimum: 0 \
			 * Maximum: 1000
			 * @default 80
			 */
			parentHeight?: number;
		};
		response: {
			thread:
				| UnionOf<'app.bsky.feed.defs#threadViewPost'>
				| UnionOf<'app.bsky.feed.defs#notFoundPost'>
				| UnionOf<'app.bsky.feed.defs#blockedPost'>;
		};
		errors: {
			NotFound: {};
		};
	};
	/**
	 * Get a view of an actor's feed.
	 */
	'app.bsky.feed.getPosts': {
		params: {
			/**
			 * Maximum array length: 25
			 */
			uris: AtUri[];
		};
		response: {
			posts: RefOf<'app.bsky.feed.defs#postView'>[];
		};
	};
	/**
	 * Get a list of reposts.
	 */
	'app.bsky.feed.getRepostedBy': {
		params: {
			uri: AtUri;
			cid?: CID;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			uri: AtUri;
			cid?: CID;
			cursor?: string;
			repostedBy: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get a list of suggested feeds for the viewer.
	 */
	'app.bsky.feed.getSuggestedFeeds': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * Get a view of the actor's home timeline.
	 */
	'app.bsky.feed.getTimeline': {
		params: {
			algorithm?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
	};
	/**
	 * Find posts matching search criteria.
	 */
	'app.bsky.feed.searchPosts': {
		params: {
			/**
			 * Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended.
			 */
			q: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			/**
			 * Optional pagination mechanism; may not necessarily allow scrolling through entire result set.
			 */
			cursor?: string;
		};
		response: {
			cursor?: string;
			/**
			 * Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits.
			 */
			hitsTotal?: number;
			posts: RefOf<'app.bsky.feed.defs#postView'>[];
		};
		errors: {
			BadQueryString: {};
		};
	};
	/**
	 * Get a list of who the actor is blocking.
	 */
	'app.bsky.graph.getBlocks': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			blocks: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get a list of an actor's followers.
	 */
	'app.bsky.graph.getFollowers': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			subject: RefOf<'app.bsky.actor.defs#profileView'>;
			cursor?: string;
			followers: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get a list of who the actor follows.
	 */
	'app.bsky.graph.getFollows': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			subject: RefOf<'app.bsky.actor.defs#profileView'>;
			cursor?: string;
			follows: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get a list of actors.
	 */
	'app.bsky.graph.getList': {
		params: {
			list: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			list: RefOf<'app.bsky.graph.defs#listView'>;
			items: RefOf<'app.bsky.graph.defs#listItemView'>[];
		};
	};
	/**
	 * Get lists that the actor is blocking.
	 */
	'app.bsky.graph.getListBlocks': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			lists: RefOf<'app.bsky.graph.defs#listView'>[];
		};
	};
	/**
	 * Get lists that the actor is muting.
	 */
	'app.bsky.graph.getListMutes': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			lists: RefOf<'app.bsky.graph.defs#listView'>[];
		};
	};
	/**
	 * Get a list of lists that belong to an actor.
	 */
	'app.bsky.graph.getLists': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			lists: RefOf<'app.bsky.graph.defs#listView'>[];
		};
	};
	/**
	 * Get a list of who the actor mutes.
	 */
	'app.bsky.graph.getMutes': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			mutes: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get suggested follows related to a given actor.
	 */
	'app.bsky.graph.getSuggestedFollowsByActor': {
		params: {
			actor: string;
		};
		response: {
			suggestions: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get the count of unread notifications.
	 */
	'app.bsky.notification.getUnreadCount': {
		params: {
			seenAt?: string;
		};
		response: {
			count: number;
		};
	};
	/**
	 * Get a list of notifications.
	 */
	'app.bsky.notification.listNotifications': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			seenAt?: string;
		};
		response: {
			cursor?: string;
			notifications: RefOf<'app.bsky.notification.listNotifications#notification'>[];
			seenAt?: string;
		};
	};
	/**
	 * An unspecced view of globally popular feed generators.
	 */
	'app.bsky.unspecced.getPopularFeedGenerators': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			query?: string;
		};
		response: {
			cursor?: string;
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * DEPRECATED: a skeleton of a timeline. Unspecced and will be unavailable soon.
	 * @deprecated
	 */
	'app.bsky.unspecced.getTimelineSkeleton': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#skeletonFeedPost'>[];
		};
		errors: {
			UnknownFeed: {};
		};
	};
	/**
	 * Backend Actors (profile) search, returns only skeleton.
	 */
	'app.bsky.unspecced.searchActorsSkeleton': {
		params: {
			/**
			 * Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax.
			 */
			q: string;
			/**
			 * If true, acts as fast/simple 'typeahead' query.
			 */
			typeahead?: boolean;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			/**
			 * Optional pagination mechanism; may not necessarily allow scrolling through entire result set.
			 */
			cursor?: string;
		};
		response: {
			cursor?: string;
			/**
			 * Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits.
			 */
			hitsTotal?: number;
			actors: RefOf<'app.bsky.unspecced.defs#skeletonSearchActor'>[];
		};
		errors: {
			BadQueryString: {};
		};
	};
	/**
	 * Backend Posts search, returns only skeleton
	 */
	'app.bsky.unspecced.searchPostsSkeleton': {
		params: {
			/**
			 * Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended.
			 */
			q: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			/**
			 * Optional pagination mechanism; may not necessarily allow scrolling through entire result set.
			 */
			cursor?: string;
		};
		response: {
			cursor?: string;
			/**
			 * Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits.
			 */
			hitsTotal?: number;
			posts: RefOf<'app.bsky.unspecced.defs#skeletonSearchPost'>[];
		};
		errors: {
			BadQueryString: {};
		};
	};
	/**
	 * Get details about an account.
	 */
	'com.atproto.admin.getAccountInfo': {
		params: {
			did: DID;
		};
		response: RefOf<'com.atproto.admin.defs#accountView'>;
	};
	/**
	 * Get details about some accounts.
	 */
	'com.atproto.admin.getAccountInfos': {
		params: {
			dids: DID[];
		};
		response: {
			infos: RefOf<'com.atproto.admin.defs#accountView'>[];
		};
	};
	/**
	 * Get an admin view of invite codes.
	 */
	'com.atproto.admin.getInviteCodes': {
		params: {
			/**
			 * @default "recent"
			 */
			sort?: 'recent' | 'usage' | (string & {});
			/**
			 * Minimum: 1 \
			 * Maximum: 500
			 * @default 100
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			codes: RefOf<'com.atproto.server.defs#inviteCode'>[];
		};
	};
	/**
	 * Get details about a moderation event.
	 */
	'com.atproto.admin.getModerationEvent': {
		params: {
			id: number;
		};
		response: RefOf<'com.atproto.admin.defs#modEventViewDetail'>;
	};
	/**
	 * Get details about a record.
	 */
	'com.atproto.admin.getRecord': {
		params: {
			uri: AtUri;
			cid?: CID;
		};
		response: RefOf<'com.atproto.admin.defs#recordViewDetail'>;
		errors: {
			RecordNotFound: {};
		};
	};
	/**
	 * Get details about a repository.
	 */
	'com.atproto.admin.getRepo': {
		params: {
			did: DID;
		};
		response: RefOf<'com.atproto.admin.defs#repoViewDetail'>;
		errors: {
			RepoNotFound: {};
		};
	};
	/**
	 * Get the service-specific admin status of a subject (account, record, or blob).
	 */
	'com.atproto.admin.getSubjectStatus': {
		params: {
			did?: DID;
			uri?: AtUri;
			blob?: CID;
		};
		response: {
			subject:
				| UnionOf<'com.atproto.admin.defs#repoRef'>
				| UnionOf<'com.atproto.repo.strongRef'>
				| UnionOf<'com.atproto.admin.defs#repoBlobRef'>;
			takedown?: RefOf<'com.atproto.admin.defs#statusAttr'>;
		};
	};
	/**
	 * Get list of all communication templates.
	 */
	'com.atproto.admin.listCommunicationTemplates': {
		response: {
			communicationTemplates: RefOf<'com.atproto.admin.defs#communicationTemplateView'>[];
		};
	};
	/**
	 * List moderation events related to a subject.
	 */
	'com.atproto.admin.queryModerationEvents': {
		params: {
			/**
			 * The types of events (fully qualified string in the format of com.atproto.admin#modEvent<name>) to filter by. If not specified, all events are returned.
			 */
			types?: string[];
			createdBy?: DID;
			/**
			 * Sort direction for the events. Defaults to descending order of created at timestamp.
			 * @default "desc"
			 */
			sortDirection?: string;
			subject?: string;
			/**
			 * If true, events on all record types (posts, lists, profile etc.) owned by the did are returned
			 * @default false
			 */
			includeAllUserRecords?: boolean;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			events: RefOf<'com.atproto.admin.defs#modEventView'>[];
		};
	};
	/**
	 * View moderation statuses of subjects (record or repo).
	 */
	'com.atproto.admin.queryModerationStatuses': {
		params: {
			subject?: string;
			/**
			 * Search subjects by keyword from comments
			 */
			comment?: string;
			/**
			 * Search subjects reported after a given timestamp
			 */
			reportedAfter?: string;
			/**
			 * Search subjects reported before a given timestamp
			 */
			reportedBefore?: string;
			/**
			 * Search subjects reviewed after a given timestamp
			 */
			reviewedAfter?: string;
			/**
			 * Search subjects reviewed before a given timestamp
			 */
			reviewedBefore?: string;
			/**
			 * By default, we don't include muted subjects in the results. Set this to true to include them.
			 */
			includeMuted?: boolean;
			/**
			 * Specify when fetching subjects in a certain state
			 */
			reviewState?: string;
			ignoreSubjects?: string[];
			/**
			 * Get all subject statuses that were reviewed by a specific moderator
			 */
			lastReviewedBy?: DID;
			/**
			 * @default "lastReportedAt"
			 */
			sortField?: string;
			/**
			 * @default "desc"
			 */
			sortDirection?: string;
			/**
			 * Get subjects that were taken down
			 */
			takendown?: boolean;
			/**
			 * Get subjects in unresolved appealed status
			 */
			appealed?: boolean;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			subjectStatuses: RefOf<'com.atproto.admin.defs#subjectStatusView'>[];
		};
	};
	/**
	 * Find repositories based on a search term.
	 */
	'com.atproto.admin.searchRepos': {
		params: {
			/**
			 * DEPRECATED: use 'q' instead
			 * @deprecated
			 */
			term?: string;
			q?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			repos: RefOf<'com.atproto.admin.defs#repoView'>[];
		};
	};
	/**
	 * Provides the DID of a repo.
	 */
	'com.atproto.identity.resolveHandle': {
		params: {
			/**
			 * The handle to resolve.
			 */
			handle: Handle;
		};
		response: {
			did: DID;
		};
	};
	/**
	 * Find labels relevant to the provided URI patterns.
	 */
	'com.atproto.label.queryLabels': {
		params: {
			/**
			 * List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI.
			 */
			uriPatterns: string[];
			/**
			 * Optional list of label sources (DIDs) to filter on.
			 */
			sources?: DID[];
			/**
			 * Minimum: 1 \
			 * Maximum: 250
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			labels: RefOf<'com.atproto.label.defs#label'>[];
		};
	};
	/**
	 * Get information about the repo, including the list of collections.
	 */
	'com.atproto.repo.describeRepo': {
		params: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
		};
		response: {
			handle: Handle;
			did: DID;
			didDoc: unknown;
			collections: string[];
			handleIsCorrect: boolean;
		};
	};
	/**
	 * Get a record.
	 */
	'com.atproto.repo.getRecord': {
		params: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record.
			 */
			rkey: string;
			/**
			 * The CID of the version of the record. If not specified, then return the most recent version.
			 */
			cid?: CID;
		};
		response: {
			uri: AtUri;
			cid?: CID;
			value: unknown;
		};
	};
	/**
	 * List a range of records in a collection.
	 */
	'com.atproto.repo.listRecords': {
		params: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record type.
			 */
			collection: string;
			/**
			 * The number of records to return. \
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			/**
			 * DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)
			 * @deprecated
			 */
			rkeyStart?: string;
			/**
			 * DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)
			 * @deprecated
			 */
			rkeyEnd?: string;
			/**
			 * Flag to reverse the order of the returned records.
			 */
			reverse?: boolean;
		};
		response: {
			cursor?: string;
			records: RefOf<'com.atproto.repo.listRecords#record'>[];
		};
	};
	/**
	 * Get a document describing the service's accounts configuration.
	 */
	'com.atproto.server.describeServer': {
		response: {
			inviteCodeRequired?: boolean;
			phoneVerificationRequired?: boolean;
			availableUserDomains: string[];
			links?: RefOf<'com.atproto.server.describeServer#links'>;
		};
	};
	/**
	 * Get all invite codes for a given account.
	 */
	'com.atproto.server.getAccountInviteCodes': {
		params: {
			/**
			 * @default true
			 */
			includeUsed?: boolean;
			/**
			 * @default true
			 */
			createAvailable?: boolean;
		};
		response: {
			codes: RefOf<'com.atproto.server.defs#inviteCode'>[];
		};
		errors: {
			DuplicateCreate: {};
		};
	};
	/**
	 * Get information about the current session.
	 */
	'com.atproto.server.getSession': {
		response: {
			handle: Handle;
			did: DID;
			email?: string;
			emailConfirmed?: boolean;
			didDoc?: unknown;
		};
	};
	/**
	 * List all App Passwords.
	 */
	'com.atproto.server.listAppPasswords': {
		response: {
			passwords: RefOf<'com.atproto.server.listAppPasswords#appPassword'>[];
		};
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Get a blob associated with a given repo.
	 */
	'com.atproto.sync.getBlob': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			/**
			 * The CID of the blob to fetch
			 */
			cid: CID;
		};
		response: unknown;
	};
	/**
	 * Get blocks from a given repo.
	 */
	'com.atproto.sync.getBlocks': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			cids: CID[];
		};
		response: unknown;
	};
	/**
	 * DEPRECATED - please use com.atproto.sync.getRepo instead
	 * @deprecated
	 */
	'com.atproto.sync.getCheckout': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		response: unknown;
	};
	/**
	 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
	 * @deprecated
	 */
	'com.atproto.sync.getHead': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		response: {
			root: CID;
		};
		errors: {
			HeadNotFound: {};
		};
	};
	/**
	 * Get the current commit CID & revision of the repo.
	 */
	'com.atproto.sync.getLatestCommit': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		response: {
			cid: CID;
			rev: string;
		};
		errors: {
			RepoNotFound: {};
		};
	};
	/**
	 * Get blocks needed for existence or non-existence of record.
	 */
	'com.atproto.sync.getRecord': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			collection: string;
			rkey: string;
			/**
			 * An optional past commit CID.
			 */
			commit?: CID;
		};
		response: unknown;
	};
	/**
	 * Gets the DID's repo, optionally catching up from a specific revision.
	 */
	'com.atproto.sync.getRepo': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			/**
			 * The revision of the repo to catch up from.
			 */
			since?: string;
		};
		response: unknown;
	};
	/**
	 * List blob CIDs since some revision.
	 */
	'com.atproto.sync.listBlobs': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			/**
			 * Optional revision of the repo to list blobs since.
			 */
			since?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 1000
			 * @default 500
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			cids: CID[];
		};
	};
	/**
	 * List DIDs and root CIDs of hosted repos.
	 */
	'com.atproto.sync.listRepos': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 1000
			 * @default 500
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			repos: RefOf<'com.atproto.sync.listRepos#repo'>[];
		};
	};
	/**
	 * Fetch all labels from a labeler created after a certain date.
	 */
	'com.atproto.temp.fetchLabels': {
		params: {
			since?: number;
			/**
			 * Minimum: 1 \
			 * Maximum: 250
			 * @default 50
			 */
			limit?: number;
		};
		response: {
			labels: RefOf<'com.atproto.label.defs#label'>[];
		};
	};
}

export interface Procedures {
	/**
	 * Set the private preferences attached to the account.
	 */
	'app.bsky.actor.putPreferences': {
		data: {
			preferences: RefOf<'app.bsky.actor.defs#preferences'>;
		};
	};
	/**
	 * Mute an actor by DID or handle.
	 */
	'app.bsky.graph.muteActor': {
		data: {
			actor: string;
		};
	};
	/**
	 * Mute a list of actors.
	 */
	'app.bsky.graph.muteActorList': {
		data: {
			list: AtUri;
		};
	};
	/**
	 * Unmute an actor by DID or handle.
	 */
	'app.bsky.graph.unmuteActor': {
		data: {
			actor: string;
		};
	};
	/**
	 * Unmute a list of actors.
	 */
	'app.bsky.graph.unmuteActorList': {
		data: {
			list: AtUri;
		};
	};
	/**
	 * Register for push notifications with a service.
	 */
	'app.bsky.notification.registerPush': {
		data: {
			serviceDid: DID;
			token: string;
			platform: 'ios' | 'android' | 'web' | (string & {});
			appId: string;
		};
	};
	/**
	 * Notify server that the user has seen notifications.
	 */
	'app.bsky.notification.updateSeen': {
		data: {
			seenAt: string;
		};
	};
	/**
	 * Administrative action to create a new, re-usable communication (email for now) template.
	 */
	'com.atproto.admin.createCommunicationTemplate': {
		data: {
			/**
			 * Name of the template.
			 */
			name: string;
			/**
			 * Content of the template, markdown supported, can contain variable placeholders.
			 */
			contentMarkdown: string;
			/**
			 * Subject of the message, used in emails.
			 */
			subject: string;
			/**
			 * DID of the user who is creating the template.
			 */
			createdBy?: DID;
		};
		response: RefOf<'com.atproto.admin.defs#communicationTemplateView'>;
	};
	/**
	 * Delete a user account as an administrator.
	 */
	'com.atproto.admin.deleteAccount': {
		data: {
			did: DID;
		};
	};
	/**
	 * Delete a communication template.
	 */
	'com.atproto.admin.deleteCommunicationTemplate': {
		data: {
			id: string;
		};
	};
	/**
	 * Disable an account from receiving new invite codes, but does not invalidate existing codes.
	 */
	'com.atproto.admin.disableAccountInvites': {
		data: {
			account: DID;
			/**
			 * Optional reason for disabled invites.
			 */
			note?: string;
		};
	};
	/**
	 * Disable some set of codes and/or all codes associated with a set of users.
	 */
	'com.atproto.admin.disableInviteCodes': {
		data: {
			codes?: string[];
			accounts?: string[];
		};
	};
	/**
	 * Take a moderation action on an actor.
	 */
	'com.atproto.admin.emitModerationEvent': {
		data: {
			event:
				| UnionOf<'com.atproto.admin.defs#modEventTakedown'>
				| UnionOf<'com.atproto.admin.defs#modEventAcknowledge'>
				| UnionOf<'com.atproto.admin.defs#modEventEscalate'>
				| UnionOf<'com.atproto.admin.defs#modEventComment'>
				| UnionOf<'com.atproto.admin.defs#modEventLabel'>
				| UnionOf<'com.atproto.admin.defs#modEventReport'>
				| UnionOf<'com.atproto.admin.defs#modEventMute'>
				| UnionOf<'com.atproto.admin.defs#modEventReverseTakedown'>
				| UnionOf<'com.atproto.admin.defs#modEventUnmute'>
				| UnionOf<'com.atproto.admin.defs#modEventEmail'>;
			subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
			subjectBlobCids?: CID[];
			createdBy: DID;
		};
		response: RefOf<'com.atproto.admin.defs#modEventView'>;
		errors: {
			SubjectHasAction: {};
		};
	};
	/**
	 * Re-enable an account's ability to receive invite codes.
	 */
	'com.atproto.admin.enableAccountInvites': {
		data: {
			account: DID;
			/**
			 * Optional reason for enabled invites.
			 */
			note?: string;
		};
	};
	/**
	 * Send email to a user's account email address.
	 */
	'com.atproto.admin.sendEmail': {
		data: {
			recipientDid: DID;
			content: string;
			subject?: string;
			senderDid: DID;
			/**
			 * Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers
			 */
			comment?: string;
		};
		response: {
			sent: boolean;
		};
	};
	/**
	 * Administrative action to update an account's email.
	 */
	'com.atproto.admin.updateAccountEmail': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			account: string;
			email: string;
		};
	};
	/**
	 * Administrative action to update an account's handle.
	 */
	'com.atproto.admin.updateAccountHandle': {
		data: {
			did: DID;
			handle: Handle;
		};
	};
	/**
	 * Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.
	 */
	'com.atproto.admin.updateCommunicationTemplate': {
		data: {
			/**
			 * ID of the template to be updated.
			 */
			id: string;
			/**
			 * Name of the template.
			 */
			name?: string;
			/**
			 * Content of the template, markdown supported, can contain variable placeholders.
			 */
			contentMarkdown?: string;
			/**
			 * Subject of the message, used in emails.
			 */
			subject?: string;
			/**
			 * DID of the user who is updating the template.
			 */
			updatedBy?: DID;
			disabled?: boolean;
		};
		response: RefOf<'com.atproto.admin.defs#communicationTemplateView'>;
	};
	/**
	 * Update the service-specific admin status of a subject (account, record, or blob).
	 */
	'com.atproto.admin.updateSubjectStatus': {
		data: {
			subject:
				| UnionOf<'com.atproto.admin.defs#repoRef'>
				| UnionOf<'com.atproto.repo.strongRef'>
				| UnionOf<'com.atproto.admin.defs#repoBlobRef'>;
			takedown?: RefOf<'com.atproto.admin.defs#statusAttr'>;
		};
		response: {
			subject:
				| UnionOf<'com.atproto.admin.defs#repoRef'>
				| UnionOf<'com.atproto.repo.strongRef'>
				| UnionOf<'com.atproto.admin.defs#repoBlobRef'>;
			takedown?: RefOf<'com.atproto.admin.defs#statusAttr'>;
		};
	};
	/**
	 * Updates the handle of the account.
	 */
	'com.atproto.identity.updateHandle': {
		data: {
			handle: Handle;
		};
	};
	/**
	 * Report a repo or a record.
	 */
	'com.atproto.moderation.createReport': {
		data: {
			reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
			reason?: string;
			subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		};
		response: {
			id: number;
			reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
			/**
			 * Maximum string length: 20000 \
			 * Maximum grapheme length: 2000
			 */
			reason?: string;
			subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
			reportedBy: DID;
			createdAt: string;
		};
	};
	/**
	 * Apply a batch transaction of creates, updates, and deletes.
	 */
	'com.atproto.repo.applyWrites': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * Flag for validating the records.
			 * @default true
			 */
			validate?: boolean;
			writes: (
				| UnionOf<'com.atproto.repo.applyWrites#create'>
				| UnionOf<'com.atproto.repo.applyWrites#update'>
				| UnionOf<'com.atproto.repo.applyWrites#delete'>
			)[];
			swapCommit?: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Create a new record.
	 */
	'com.atproto.repo.createRecord': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record. \
			 * Maximum string length: 15
			 */
			rkey?: string;
			/**
			 * Flag for validating the record.
			 * @default true
			 */
			validate?: boolean;
			/**
			 * The record to create.
			 */
			record: unknown;
			/**
			 * Compare and swap with the previous commit by CID.
			 */
			swapCommit?: CID;
		};
		response: {
			uri: AtUri;
			cid: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Delete a record, or ensure it doesn't exist.
	 */
	'com.atproto.repo.deleteRecord': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record.
			 */
			rkey: string;
			/**
			 * Compare and swap with the previous record by CID.
			 */
			swapRecord?: CID;
			/**
			 * Compare and swap with the previous commit by CID.
			 */
			swapCommit?: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Write a record, creating or updating it as needed.
	 */
	'com.atproto.repo.putRecord': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record. \
			 * Maximum string length: 15
			 */
			rkey: string;
			/**
			 * Flag for validating the record.
			 * @default true
			 */
			validate?: boolean;
			/**
			 * The record to write.
			 */
			record: unknown;
			/**
			 * Compare and swap with the previous record by CID.
			 */
			swapRecord?: CID;
			/**
			 * Compare and swap with the previous commit by CID.
			 */
			swapCommit?: CID;
		};
		response: {
			uri: AtUri;
			cid: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Upload a new blob to be added to repo in a later request.
	 */
	'com.atproto.repo.uploadBlob': {
		data: Blob;
		response: {
			blob: AtBlob;
		};
	};
	/**
	 * Confirm an email using a token from com.atproto.server.requestEmailConfirmation.
	 */
	'com.atproto.server.confirmEmail': {
		data: {
			email: string;
			token: string;
		};
		errors: {
			AccountNotFound: {};
			ExpiredToken: {};
			InvalidToken: {};
			InvalidEmail: {};
		};
	};
	/**
	 * Create an account.
	 */
	'com.atproto.server.createAccount': {
		data: {
			email?: string;
			handle: Handle;
			did?: DID;
			inviteCode?: string;
			verificationCode?: string;
			verificationPhone?: string;
			password?: string;
			recoveryKey?: string;
			plcOp?: unknown;
		};
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
			didDoc?: unknown;
		};
		errors: {
			InvalidHandle: {};
			InvalidPassword: {};
			InvalidInviteCode: {};
			HandleNotAvailable: {};
			UnsupportedDomain: {};
			UnresolvableDid: {};
			IncompatibleDidDoc: {};
		};
	};
	/**
	 * Create an App Password.
	 */
	'com.atproto.server.createAppPassword': {
		data: {
			name: string;
		};
		response: RefOf<'com.atproto.server.createAppPassword#appPassword'>;
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Create an invite code.
	 */
	'com.atproto.server.createInviteCode': {
		data: {
			useCount: number;
			forAccount?: DID;
		};
		response: {
			code: string;
		};
	};
	/**
	 * Create invite codes.
	 */
	'com.atproto.server.createInviteCodes': {
		data: {
			/**
			 * @default 1
			 */
			codeCount: number;
			useCount: number;
			forAccounts?: DID[];
		};
		response: {
			codes: RefOf<'com.atproto.server.createInviteCodes#accountCodes'>[];
		};
	};
	/**
	 * Create an authentication session.
	 */
	'com.atproto.server.createSession': {
		data: {
			/**
			 * Handle or other identifier supported by the server for the authenticating user.
			 */
			identifier: string;
			password: string;
		};
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
			didDoc?: unknown;
			email?: string;
			emailConfirmed?: boolean;
		};
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Delete an actor's account with a token and password.
	 */
	'com.atproto.server.deleteAccount': {
		data: {
			did: DID;
			password: string;
			token: string;
		};
		errors: {
			ExpiredToken: {};
			InvalidToken: {};
		};
	};
	/**
	 * Delete the current session.
	 */
	'com.atproto.server.deleteSession': {};
	/**
	 * Refresh an authentication session.
	 */
	'com.atproto.server.refreshSession': {
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
			didDoc?: unknown;
		};
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Initiate a user account deletion via email.
	 */
	'com.atproto.server.requestAccountDelete': {};
	/**
	 * Request an email with a code to confirm ownership of email.
	 */
	'com.atproto.server.requestEmailConfirmation': {};
	/**
	 * Request a token in order to update email.
	 */
	'com.atproto.server.requestEmailUpdate': {
		response: {
			tokenRequired: boolean;
		};
	};
	/**
	 * Initiate a user account password reset via email.
	 */
	'com.atproto.server.requestPasswordReset': {
		data: {
			email: string;
		};
	};
	/**
	 * Reserve a repo signing key for account creation.
	 */
	'com.atproto.server.reserveSigningKey': {
		data: {
			/**
			 * The did to reserve a new did:key for
			 */
			did?: string;
		};
		response: {
			/**
			 * Public signing key in the form of a did:key.
			 */
			signingKey: string;
		};
	};
	/**
	 * Reset a user account password using a token.
	 */
	'com.atproto.server.resetPassword': {
		data: {
			token: string;
			password: string;
		};
		errors: {
			ExpiredToken: {};
			InvalidToken: {};
		};
	};
	/**
	 * Revoke an App Password by name.
	 */
	'com.atproto.server.revokeAppPassword': {
		data: {
			name: string;
		};
	};
	/**
	 * Update an account's email.
	 */
	'com.atproto.server.updateEmail': {
		data: {
			email: string;
			/**
			 * Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed.
			 */
			token?: string;
		};
		errors: {
			ExpiredToken: {};
			InvalidToken: {};
			TokenRequired: {};
		};
	};
	/**
	 * Notify a crawling service of a recent update; often when a long break between updates causes the connection with the crawling service to break.
	 */
	'com.atproto.sync.notifyOfUpdate': {
		data: {
			/**
			 * Hostname of the service that is notifying of update.
			 */
			hostname: string;
		};
	};
	/**
	 * Request a service to persistently crawl hosted repos.
	 */
	'com.atproto.sync.requestCrawl': {
		data: {
			/**
			 * Hostname of the service that is requesting to be crawled.
			 */
			hostname: string;
		};
	};
	/**
	 * Gets the did's repo, optionally catching up from a specific revision.
	 */
	'com.atproto.temp.importRepo': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		data: Blob;
		response: unknown;
	};
	/**
	 * Gets the did's repo, optionally catching up from a specific revision.
	 */
	'com.atproto.temp.pushBlob': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		data: Blob;
	};
	/**
	 * Request a verification code to be sent to the supplied phone number
	 */
	'com.atproto.temp.requestPhoneVerification': {
		data: {
			phoneNumber: string;
		};
	};
	/**
	 * Transfer an account.
	 */
	'com.atproto.temp.transferAccount': {
		data: {
			handle: Handle;
			did: DID;
			plcOp: unknown;
		};
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
		};
		errors: {
			InvalidHandle: {};
			InvalidPassword: {};
			InvalidInviteCode: {};
			HandleNotAvailable: {};
			UnsupportedDomain: {};
			UnresolvableDid: {};
			IncompatibleDidDoc: {};
		};
	};
}

export interface Subscriptions {}

export interface Objects {
	'app.bsky.actor.defs#profileViewBasic': {
		did: DID;
		handle: Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		avatar?: string;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.actor.defs#profileView': {
		did: DID;
		handle: Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: string;
		indexedAt?: string;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.actor.defs#profileViewDetailed': {
		did: DID;
		handle: Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: string;
		banner?: string;
		followersCount?: number;
		followsCount?: number;
		postsCount?: number;
		indexedAt?: string;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.actor.defs#viewerState': {
		muted?: boolean;
		mutedByList?: RefOf<'app.bsky.graph.defs#listViewBasic'>;
		blockedBy?: boolean;
		blocking?: AtUri;
		blockingByList?: RefOf<'app.bsky.graph.defs#listViewBasic'>;
		following?: AtUri;
		followedBy?: AtUri;
	};
	'app.bsky.actor.defs#preferences': (
		| UnionOf<'app.bsky.actor.defs#adultContentPref'>
		| UnionOf<'app.bsky.actor.defs#contentLabelPref'>
		| UnionOf<'app.bsky.actor.defs#savedFeedsPref'>
		| UnionOf<'app.bsky.actor.defs#personalDetailsPref'>
		| UnionOf<'app.bsky.actor.defs#feedViewPref'>
		| UnionOf<'app.bsky.actor.defs#threadViewPref'>
	)[];
	'app.bsky.actor.defs#adultContentPref': {
		/**
		 * @default false
		 */
		enabled: boolean;
	};
	'app.bsky.actor.defs#contentLabelPref': {
		label: string;
		visibility: 'show' | 'warn' | 'hide' | (string & {});
	};
	'app.bsky.actor.defs#savedFeedsPref': {
		pinned: AtUri[];
		saved: AtUri[];
	};
	'app.bsky.actor.defs#personalDetailsPref': {
		/**
		 * The birth date of account owner.
		 */
		birthDate?: string;
	};
	'app.bsky.actor.defs#feedViewPref': {
		/**
		 * The URI of the feed, or an identifier which describes the feed.
		 */
		feed: string;
		/**
		 * Hide replies in the feed.
		 */
		hideReplies?: boolean;
		/**
		 * Hide replies in the feed if they are not by followed users.
		 */
		hideRepliesByUnfollowed?: boolean;
		/**
		 * Hide replies in the feed if they do not have this number of likes.
		 */
		hideRepliesByLikeCount?: number;
		/**
		 * Hide reposts in the feed.
		 */
		hideReposts?: boolean;
		/**
		 * Hide quote posts in the feed.
		 */
		hideQuotePosts?: boolean;
	};
	'app.bsky.actor.defs#threadViewPref': {
		/**
		 * Sorting mode for threads.
		 */
		sort?: 'oldest' | 'newest' | 'most-likes' | 'random' | (string & {});
		/**
		 * Show followed users at the top of all replies.
		 */
		prioritizeFollowedUsers?: boolean;
	};
	'app.bsky.embed.external': {
		external: RefOf<'app.bsky.embed.external#external'>;
	};
	'app.bsky.embed.external#external': {
		uri: string;
		title: string;
		description: string;
		thumb?: AtBlob<`image/${string}`>;
	};
	'app.bsky.embed.external#view': {
		external: RefOf<'app.bsky.embed.external#viewExternal'>;
	};
	'app.bsky.embed.external#viewExternal': {
		uri: string;
		title: string;
		description: string;
		thumb?: string;
	};
	'app.bsky.embed.images': {
		/**
		 * Maximum array length: 4
		 */
		images: RefOf<'app.bsky.embed.images#image'>[];
	};
	'app.bsky.embed.images#image': {
		image: AtBlob<`image/${string}`>;
		alt: string;
		aspectRatio?: RefOf<'app.bsky.embed.images#aspectRatio'>;
	};
	/**
	 * width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.
	 */
	'app.bsky.embed.images#aspectRatio': {
		/**
		 * Minimum: 1
		 */
		width: number;
		/**
		 * Minimum: 1
		 */
		height: number;
	};
	'app.bsky.embed.images#view': {
		/**
		 * Maximum array length: 4
		 */
		images: RefOf<'app.bsky.embed.images#viewImage'>[];
	};
	'app.bsky.embed.images#viewImage': {
		thumb: string;
		fullsize: string;
		alt: string;
		aspectRatio?: RefOf<'app.bsky.embed.images#aspectRatio'>;
	};
	'app.bsky.embed.record': {
		record: RefOf<'com.atproto.repo.strongRef'>;
	};
	'app.bsky.embed.record#view': {
		record:
			| UnionOf<'app.bsky.embed.record#viewRecord'>
			| UnionOf<'app.bsky.embed.record#viewNotFound'>
			| UnionOf<'app.bsky.embed.record#viewBlocked'>
			| UnionOf<'app.bsky.feed.defs#generatorView'>
			| UnionOf<'app.bsky.graph.defs#listView'>;
	};
	'app.bsky.embed.record#viewRecord': {
		uri: AtUri;
		cid: CID;
		author: RefOf<'app.bsky.actor.defs#profileViewBasic'>;
		value: unknown;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		embeds?: (
			| UnionOf<'app.bsky.embed.images#view'>
			| UnionOf<'app.bsky.embed.external#view'>
			| UnionOf<'app.bsky.embed.record#view'>
			| UnionOf<'app.bsky.embed.recordWithMedia#view'>
		)[];
		indexedAt: string;
	};
	'app.bsky.embed.record#viewNotFound': {
		uri: AtUri;
		notFound: boolean;
	};
	'app.bsky.embed.record#viewBlocked': {
		uri: AtUri;
		blocked: boolean;
		author: RefOf<'app.bsky.feed.defs#blockedAuthor'>;
	};
	'app.bsky.embed.recordWithMedia': {
		record: RefOf<'app.bsky.embed.record'>;
		media: UnionOf<'app.bsky.embed.images'> | UnionOf<'app.bsky.embed.external'>;
	};
	'app.bsky.embed.recordWithMedia#view': {
		record: RefOf<'app.bsky.embed.record#view'>;
		media: UnionOf<'app.bsky.embed.images#view'> | UnionOf<'app.bsky.embed.external#view'>;
	};
	'app.bsky.feed.defs#postView': {
		uri: AtUri;
		cid: CID;
		author: RefOf<'app.bsky.actor.defs#profileViewBasic'>;
		record: unknown;
		embed?:
			| UnionOf<'app.bsky.embed.images#view'>
			| UnionOf<'app.bsky.embed.external#view'>
			| UnionOf<'app.bsky.embed.record#view'>
			| UnionOf<'app.bsky.embed.recordWithMedia#view'>;
		replyCount?: number;
		repostCount?: number;
		likeCount?: number;
		indexedAt: string;
		viewer?: RefOf<'app.bsky.feed.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		threadgate?: RefOf<'app.bsky.feed.defs#threadgateView'>;
	};
	'app.bsky.feed.defs#viewerState': {
		repost?: AtUri;
		like?: AtUri;
		replyDisabled?: boolean;
	};
	'app.bsky.feed.defs#feedViewPost': {
		post: RefOf<'app.bsky.feed.defs#postView'>;
		reply?: RefOf<'app.bsky.feed.defs#replyRef'>;
		reason?: UnionOf<'app.bsky.feed.defs#reasonRepost'>;
	};
	'app.bsky.feed.defs#replyRef': {
		root:
			| UnionOf<'app.bsky.feed.defs#postView'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>;
		parent:
			| UnionOf<'app.bsky.feed.defs#postView'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>;
	};
	'app.bsky.feed.defs#reasonRepost': {
		by: RefOf<'app.bsky.actor.defs#profileViewBasic'>;
		indexedAt: string;
	};
	'app.bsky.feed.defs#threadViewPost': {
		post: RefOf<'app.bsky.feed.defs#postView'>;
		parent?:
			| UnionOf<'app.bsky.feed.defs#threadViewPost'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>;
		replies?: (
			| UnionOf<'app.bsky.feed.defs#threadViewPost'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>
		)[];
	};
	'app.bsky.feed.defs#notFoundPost': {
		uri: AtUri;
		notFound: boolean;
	};
	'app.bsky.feed.defs#blockedPost': {
		uri: AtUri;
		blocked: boolean;
		author: RefOf<'app.bsky.feed.defs#blockedAuthor'>;
	};
	'app.bsky.feed.defs#blockedAuthor': {
		did: DID;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
	};
	'app.bsky.feed.defs#generatorView': {
		uri: AtUri;
		cid: CID;
		did: DID;
		creator: RefOf<'app.bsky.actor.defs#profileView'>;
		displayName: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: string;
		/**
		 * Minimum: 0
		 */
		likeCount?: number;
		viewer?: RefOf<'app.bsky.feed.defs#generatorViewerState'>;
		indexedAt: string;
	};
	'app.bsky.feed.defs#generatorViewerState': {
		like?: AtUri;
	};
	'app.bsky.feed.defs#skeletonFeedPost': {
		post: AtUri;
		reason?: UnionOf<'app.bsky.feed.defs#skeletonReasonRepost'>;
	};
	'app.bsky.feed.defs#skeletonReasonRepost': {
		repost: AtUri;
	};
	'app.bsky.feed.defs#threadgateView': {
		uri?: AtUri;
		cid?: CID;
		record?: unknown;
		lists?: RefOf<'app.bsky.graph.defs#listViewBasic'>[];
	};
	'app.bsky.feed.describeFeedGenerator#feed': {
		uri: AtUri;
	};
	'app.bsky.feed.describeFeedGenerator#links': {
		privacyPolicy?: string;
		termsOfService?: string;
	};
	'app.bsky.feed.getLikes#like': {
		indexedAt: string;
		createdAt: string;
		actor: RefOf<'app.bsky.actor.defs#profileView'>;
	};
	'app.bsky.feed.post#replyRef': {
		root: RefOf<'com.atproto.repo.strongRef'>;
		parent: RefOf<'com.atproto.repo.strongRef'>;
	};
	/**
	 * Deprecated: use facets instead.
	 * @deprecated
	 */
	'app.bsky.feed.post#entity': {
		index: RefOf<'app.bsky.feed.post#textSlice'>;
		/**
		 * Expected values are 'mention' and 'link'.
		 */
		type: string;
		value: string;
	};
	/**
	 * Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.
	 * @deprecated
	 */
	'app.bsky.feed.post#textSlice': {
		/**
		 * Minimum: 0
		 */
		start: number;
		/**
		 * Minimum: 0
		 */
		end: number;
	};
	/**
	 * Allow replies from actors mentioned in your post.
	 */
	'app.bsky.feed.threadgate#mentionRule': {};
	/**
	 * Allow replies from actors you follow.
	 */
	'app.bsky.feed.threadgate#followingRule': {};
	/**
	 * Allow replies from actors on a list.
	 */
	'app.bsky.feed.threadgate#listRule': {
		list: AtUri;
	};
	'app.bsky.graph.defs#listViewBasic': {
		uri: AtUri;
		cid: CID;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		purpose: RefOf<'app.bsky.graph.defs#listPurpose'>;
		avatar?: string;
		viewer?: RefOf<'app.bsky.graph.defs#listViewerState'>;
		indexedAt?: string;
	};
	'app.bsky.graph.defs#listView': {
		uri: AtUri;
		cid: CID;
		creator: RefOf<'app.bsky.actor.defs#profileView'>;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		purpose: RefOf<'app.bsky.graph.defs#listPurpose'>;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: string;
		viewer?: RefOf<'app.bsky.graph.defs#listViewerState'>;
		indexedAt: string;
	};
	'app.bsky.graph.defs#listItemView': {
		uri: AtUri;
		subject: RefOf<'app.bsky.actor.defs#profileView'>;
	};
	'app.bsky.graph.defs#listPurpose':
		| 'app.bsky.graph.defs#modlist'
		| 'app.bsky.graph.defs#curatelist'
		| (string & {});
	'app.bsky.graph.defs#modlist': 'app.bsky.graph.defs#modlist';
	'app.bsky.graph.defs#curatelist': 'app.bsky.graph.defs#curatelist';
	'app.bsky.graph.defs#listViewerState': {
		muted?: boolean;
		blocked?: AtUri;
	};
	'app.bsky.notification.listNotifications#notification': {
		uri: AtUri;
		cid: CID;
		author: RefOf<'app.bsky.actor.defs#profileView'>;
		/**
		 * Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.
		 */
		reason: 'like' | 'repost' | 'follow' | 'mention' | 'reply' | 'quote' | (string & {});
		reasonSubject?: AtUri;
		record: unknown;
		isRead: boolean;
		indexedAt: string;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.richtext.facet': {
		index: RefOf<'app.bsky.richtext.facet#byteSlice'>;
		features: (
			| UnionOf<'app.bsky.richtext.facet#mention'>
			| UnionOf<'app.bsky.richtext.facet#link'>
			| UnionOf<'app.bsky.richtext.facet#tag'>
		)[];
	};
	/**
	 * A facet feature for actor mentions.
	 */
	'app.bsky.richtext.facet#mention': {
		did: DID;
	};
	/**
	 * A facet feature for links.
	 */
	'app.bsky.richtext.facet#link': {
		uri: string;
	};
	/**
	 * A hashtag.
	 */
	'app.bsky.richtext.facet#tag': {
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tag: string;
	};
	/**
	 * A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.
	 */
	'app.bsky.richtext.facet#byteSlice': {
		/**
		 * Minimum: 0
		 */
		byteStart: number;
		/**
		 * Minimum: 0
		 */
		byteEnd: number;
	};
	'app.bsky.unspecced.defs#skeletonSearchPost': {
		uri: AtUri;
	};
	'app.bsky.unspecced.defs#skeletonSearchActor': {
		did: DID;
	};
	'com.atproto.admin.defs#statusAttr': {
		applied: boolean;
		ref?: string;
	};
	'com.atproto.admin.defs#modEventView': {
		id: number;
		event:
			| UnionOf<'com.atproto.admin.defs#modEventTakedown'>
			| UnionOf<'com.atproto.admin.defs#modEventReverseTakedown'>
			| UnionOf<'com.atproto.admin.defs#modEventComment'>
			| UnionOf<'com.atproto.admin.defs#modEventReport'>
			| UnionOf<'com.atproto.admin.defs#modEventLabel'>
			| UnionOf<'com.atproto.admin.defs#modEventAcknowledge'>
			| UnionOf<'com.atproto.admin.defs#modEventEscalate'>
			| UnionOf<'com.atproto.admin.defs#modEventMute'>
			| UnionOf<'com.atproto.admin.defs#modEventEmail'>;
		subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		subjectBlobCids: string[];
		createdBy: DID;
		createdAt: string;
		creatorHandle?: string;
		subjectHandle?: string;
	};
	'com.atproto.admin.defs#modEventViewDetail': {
		id: number;
		event:
			| UnionOf<'com.atproto.admin.defs#modEventTakedown'>
			| UnionOf<'com.atproto.admin.defs#modEventReverseTakedown'>
			| UnionOf<'com.atproto.admin.defs#modEventComment'>
			| UnionOf<'com.atproto.admin.defs#modEventReport'>
			| UnionOf<'com.atproto.admin.defs#modEventLabel'>
			| UnionOf<'com.atproto.admin.defs#modEventAcknowledge'>
			| UnionOf<'com.atproto.admin.defs#modEventEscalate'>
			| UnionOf<'com.atproto.admin.defs#modEventMute'>
			| UnionOf<'com.atproto.admin.defs#modEventResolveAppeal'>;
		subject:
			| UnionOf<'com.atproto.admin.defs#repoView'>
			| UnionOf<'com.atproto.admin.defs#repoViewNotFound'>
			| UnionOf<'com.atproto.admin.defs#recordView'>
			| UnionOf<'com.atproto.admin.defs#recordViewNotFound'>;
		subjectBlobs: RefOf<'com.atproto.admin.defs#blobView'>[];
		createdBy: DID;
		createdAt: string;
	};
	'com.atproto.admin.defs#reportView': {
		id: number;
		reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
		comment?: string;
		subjectRepoHandle?: string;
		subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		reportedBy: DID;
		createdAt: string;
		resolvedByActionIds: number[];
	};
	'com.atproto.admin.defs#subjectStatusView': {
		id: number;
		subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		subjectBlobCids?: CID[];
		subjectRepoHandle?: string;
		/**
		 * Timestamp referencing when the last update was made to the moderation status of the subject
		 */
		updatedAt: string;
		/**
		 * Timestamp referencing the first moderation status impacting event was emitted on the subject
		 */
		createdAt: string;
		reviewState: RefOf<'com.atproto.admin.defs#subjectReviewState'>;
		/**
		 * Sticky comment on the subject.
		 */
		comment?: string;
		muteUntil?: string;
		lastReviewedBy?: DID;
		lastReviewedAt?: string;
		lastReportedAt?: string;
		/**
		 * Timestamp referencing when the author of the subject appealed a moderation action
		 */
		lastAppealedAt?: string;
		takendown?: boolean;
		/**
		 * True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators.
		 */
		appealed?: boolean;
		suspendUntil?: string;
	};
	'com.atproto.admin.defs#reportViewDetail': {
		id: number;
		reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
		comment?: string;
		subject:
			| UnionOf<'com.atproto.admin.defs#repoView'>
			| UnionOf<'com.atproto.admin.defs#repoViewNotFound'>
			| UnionOf<'com.atproto.admin.defs#recordView'>
			| UnionOf<'com.atproto.admin.defs#recordViewNotFound'>;
		subjectStatus?: RefOf<'com.atproto.admin.defs#subjectStatusView'>;
		reportedBy: DID;
		createdAt: string;
		resolvedByActions: RefOf<'com.atproto.admin.defs#modEventView'>[];
	};
	'com.atproto.admin.defs#repoView': {
		did: DID;
		handle: Handle;
		email?: string;
		relatedRecords: unknown[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderation'>;
		invitedBy?: RefOf<'com.atproto.server.defs#inviteCode'>;
		invitesDisabled?: boolean;
		inviteNote?: string;
	};
	'com.atproto.admin.defs#repoViewDetail': {
		did: DID;
		handle: Handle;
		email?: string;
		relatedRecords: unknown[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderationDetail'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		invitedBy?: RefOf<'com.atproto.server.defs#inviteCode'>;
		invites?: RefOf<'com.atproto.server.defs#inviteCode'>[];
		invitesDisabled?: boolean;
		inviteNote?: string;
		emailConfirmedAt?: string;
	};
	'com.atproto.admin.defs#accountView': {
		did: DID;
		handle: Handle;
		email?: string;
		relatedRecords?: unknown[];
		indexedAt: string;
		invitedBy?: RefOf<'com.atproto.server.defs#inviteCode'>;
		invites?: RefOf<'com.atproto.server.defs#inviteCode'>[];
		invitesDisabled?: boolean;
		emailConfirmedAt?: string;
		inviteNote?: string;
	};
	'com.atproto.admin.defs#repoViewNotFound': {
		did: DID;
	};
	'com.atproto.admin.defs#repoRef': {
		did: DID;
	};
	'com.atproto.admin.defs#repoBlobRef': {
		did: DID;
		cid: CID;
		recordUri?: AtUri;
	};
	'com.atproto.admin.defs#recordView': {
		uri: AtUri;
		cid: CID;
		value: unknown;
		blobCids: CID[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderation'>;
		repo: RefOf<'com.atproto.admin.defs#repoView'>;
	};
	'com.atproto.admin.defs#recordViewDetail': {
		uri: AtUri;
		cid: CID;
		value: unknown;
		blobs: RefOf<'com.atproto.admin.defs#blobView'>[];
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderationDetail'>;
		repo: RefOf<'com.atproto.admin.defs#repoView'>;
	};
	'com.atproto.admin.defs#recordViewNotFound': {
		uri: AtUri;
	};
	'com.atproto.admin.defs#moderation': {
		subjectStatus?: RefOf<'com.atproto.admin.defs#subjectStatusView'>;
	};
	'com.atproto.admin.defs#moderationDetail': {
		subjectStatus?: RefOf<'com.atproto.admin.defs#subjectStatusView'>;
	};
	'com.atproto.admin.defs#blobView': {
		cid: CID;
		mimeType: string;
		size: number;
		createdAt: string;
		details?: UnionOf<'com.atproto.admin.defs#imageDetails'> | UnionOf<'com.atproto.admin.defs#videoDetails'>;
		moderation?: RefOf<'com.atproto.admin.defs#moderation'>;
	};
	'com.atproto.admin.defs#imageDetails': {
		width: number;
		height: number;
	};
	'com.atproto.admin.defs#videoDetails': {
		width: number;
		height: number;
		length: number;
	};
	'com.atproto.admin.defs#subjectReviewState':
		| '#reviewOpen'
		| '#reviewEscalated'
		| '#reviewClosed'
		| (string & {});
	'com.atproto.admin.defs#reviewOpen': 'com.atproto.admin.defs#reviewOpen';
	'com.atproto.admin.defs#reviewEscalated': 'com.atproto.admin.defs#reviewEscalated';
	'com.atproto.admin.defs#reviewClosed': 'com.atproto.admin.defs#reviewClosed';
	/**
	 * Take down a subject permanently or temporarily
	 */
	'com.atproto.admin.defs#modEventTakedown': {
		comment?: string;
		/**
		 * Indicates how long the takedown should be in effect before automatically expiring.
		 */
		durationInHours?: number;
	};
	/**
	 * Revert take down action on a subject
	 */
	'com.atproto.admin.defs#modEventReverseTakedown': {
		/**
		 * Describe reasoning behind the reversal.
		 */
		comment?: string;
	};
	/**
	 * Resolve appeal on a subject
	 */
	'com.atproto.admin.defs#modEventResolveAppeal': {
		/**
		 * Describe resolution.
		 */
		comment?: string;
	};
	/**
	 * Add a comment to a subject
	 */
	'com.atproto.admin.defs#modEventComment': {
		comment: string;
		/**
		 * Make the comment persistent on the subject
		 */
		sticky?: boolean;
	};
	/**
	 * Report a subject
	 */
	'com.atproto.admin.defs#modEventReport': {
		comment?: string;
		reportType: RefOf<'com.atproto.moderation.defs#reasonType'>;
	};
	/**
	 * Apply/Negate labels on a subject
	 */
	'com.atproto.admin.defs#modEventLabel': {
		comment?: string;
		createLabelVals: string[];
		negateLabelVals: string[];
	};
	'com.atproto.admin.defs#modEventAcknowledge': {
		comment?: string;
	};
	'com.atproto.admin.defs#modEventEscalate': {
		comment?: string;
	};
	/**
	 * Mute incoming reports on a subject
	 */
	'com.atproto.admin.defs#modEventMute': {
		comment?: string;
		/**
		 * Indicates how long the subject should remain muted.
		 */
		durationInHours: number;
	};
	/**
	 * Unmute action on a subject
	 */
	'com.atproto.admin.defs#modEventUnmute': {
		/**
		 * Describe reasoning behind the reversal.
		 */
		comment?: string;
	};
	/**
	 * Keep a log of outgoing email to a user
	 */
	'com.atproto.admin.defs#modEventEmail': {
		/**
		 * The subject line of the email sent to the user.
		 */
		subjectLine: string;
		/**
		 * Additional comment about the outgoing comm.
		 */
		comment?: string;
	};
	'com.atproto.admin.defs#communicationTemplateView': {
		id: string;
		/**
		 * Name of the template.
		 */
		name: string;
		/**
		 * Content of the template, can contain markdown and variable placeholders.
		 */
		subject?: string;
		/**
		 * Subject of the message, used in emails.
		 */
		contentMarkdown: string;
		disabled: boolean;
		/**
		 * DID of the user who last updated the template.
		 */
		lastUpdatedBy: DID;
		createdAt: string;
		updatedAt: string;
	};
	/**
	 * Metadata tag on an atproto resource (eg, repo or record).
	 */
	'com.atproto.label.defs#label': {
		/**
		 * DID of the actor who created this label.
		 */
		src: DID;
		/**
		 * AT URI of the record, repository (account), or other resource that this label applies to.
		 */
		uri: string;
		/**
		 * Optionally, CID specifying the specific version of 'uri' resource this label applies to.
		 */
		cid?: CID;
		/**
		 * The short string name of the value or type of this label. \
		 * Maximum string length: 128
		 */
		val: string;
		/**
		 * If true, this is a negation label, overwriting a previous label.
		 */
		neg?: boolean;
		/**
		 * Timestamp when this label was created.
		 */
		cts: string;
	};
	/**
	 * Metadata tags on an atproto record, published by the author within the record.
	 */
	'com.atproto.label.defs#selfLabels': {
		/**
		 * Maximum array length: 10
		 */
		values: RefOf<'com.atproto.label.defs#selfLabel'>[];
	};
	/**
	 * Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.
	 */
	'com.atproto.label.defs#selfLabel': {
		/**
		 * The short string name of the value or type of this label. \
		 * Maximum string length: 128
		 */
		val: string;
	};
	'com.atproto.label.subscribeLabels#labels': {
		seq: number;
		labels: RefOf<'com.atproto.label.defs#label'>[];
	};
	'com.atproto.label.subscribeLabels#info': {
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	};
	'com.atproto.moderation.defs#reasonType':
		| 'com.atproto.moderation.defs#reasonSpam'
		| 'com.atproto.moderation.defs#reasonViolation'
		| 'com.atproto.moderation.defs#reasonMisleading'
		| 'com.atproto.moderation.defs#reasonSexual'
		| 'com.atproto.moderation.defs#reasonRude'
		| 'com.atproto.moderation.defs#reasonOther'
		| 'com.atproto.moderation.defs#reasonAppeal'
		| (string & {});
	'com.atproto.moderation.defs#reasonSpam': 'com.atproto.moderation.defs#reasonSpam';
	'com.atproto.moderation.defs#reasonViolation': 'com.atproto.moderation.defs#reasonViolation';
	'com.atproto.moderation.defs#reasonMisleading': 'com.atproto.moderation.defs#reasonMisleading';
	'com.atproto.moderation.defs#reasonSexual': 'com.atproto.moderation.defs#reasonSexual';
	'com.atproto.moderation.defs#reasonRude': 'com.atproto.moderation.defs#reasonRude';
	'com.atproto.moderation.defs#reasonOther': 'com.atproto.moderation.defs#reasonOther';
	'com.atproto.moderation.defs#reasonAppeal': 'com.atproto.moderation.defs#reasonAppeal';
	/**
	 * Create a new record.
	 */
	'com.atproto.repo.applyWrites#create': {
		collection: string;
		/**
		 * Maximum string length: 15
		 */
		rkey?: string;
		value: unknown;
	};
	/**
	 * Update an existing record.
	 */
	'com.atproto.repo.applyWrites#update': {
		collection: string;
		rkey: string;
		value: unknown;
	};
	/**
	 * Delete an existing record.
	 */
	'com.atproto.repo.applyWrites#delete': {
		collection: string;
		rkey: string;
	};
	'com.atproto.repo.listRecords#record': {
		uri: AtUri;
		cid: CID;
		value: unknown;
	};
	'com.atproto.repo.strongRef': {
		uri: AtUri;
		cid: CID;
	};
	'com.atproto.server.createAppPassword#appPassword': {
		name: string;
		password: string;
		createdAt: string;
	};
	'com.atproto.server.createInviteCodes#accountCodes': {
		account: string;
		codes: string[];
	};
	'com.atproto.server.defs#inviteCode': {
		code: string;
		available: number;
		disabled: boolean;
		forAccount: string;
		createdBy: string;
		createdAt: string;
		uses: RefOf<'com.atproto.server.defs#inviteCodeUse'>[];
	};
	'com.atproto.server.defs#inviteCodeUse': {
		usedBy: DID;
		usedAt: string;
	};
	'com.atproto.server.describeServer#links': {
		privacyPolicy?: string;
		termsOfService?: string;
	};
	'com.atproto.server.listAppPasswords#appPassword': {
		name: string;
		createdAt: string;
	};
	'com.atproto.sync.listRepos#repo': {
		did: DID;
		head: CID;
		rev: string;
	};
	'com.atproto.sync.subscribeRepos#commit': {
		seq: number;
		rebase: boolean;
		tooBig: boolean;
		repo: DID;
		commit: unknown;
		prev?: unknown;
		/**
		 * The rev of the emitted commit.
		 */
		rev: string;
		/**
		 * The rev of the last emitted commit from this repo.
		 */
		since: string;
		/**
		 * CAR file containing relevant blocks.
		 */
		blocks: unknown;
		/**
		 * Maximum array length: 200
		 */
		ops: RefOf<'com.atproto.sync.subscribeRepos#repoOp'>[];
		blobs: unknown[];
		time: string;
	};
	'com.atproto.sync.subscribeRepos#handle': {
		seq: number;
		did: DID;
		handle: Handle;
		time: string;
	};
	'com.atproto.sync.subscribeRepos#migrate': {
		seq: number;
		did: DID;
		migrateTo: string;
		time: string;
	};
	'com.atproto.sync.subscribeRepos#tombstone': {
		seq: number;
		did: DID;
		time: string;
	};
	'com.atproto.sync.subscribeRepos#info': {
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	};
	/**
	 * A repo operation, ie a write of a single record. For creates and updates, CID is the record's CID as of this operation. For deletes, it's null.
	 */
	'com.atproto.sync.subscribeRepos#repoOp': {
		action: 'create' | 'update' | 'delete' | (string & {});
		path: string;
		cid: unknown;
	};
}

export interface Records {
	/**
	 * A declaration of a profile.
	 */
	'app.bsky.actor.profile': {
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: AtBlob<`image/png` | `image/jpeg`>;
		banner?: AtBlob<`image/png` | `image/jpeg`>;
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
	};
	/**
	 * A declaration of the existence of a feed generator.
	 */
	'app.bsky.feed.generator': {
		did: DID;
		/**
		 * Maximum string length: 240 \
		 * Maximum grapheme length: 24
		 */
		displayName: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: AtBlob<`image/png` | `image/jpeg`>;
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
		createdAt: string;
	};
	/**
	 * A declaration of a like.
	 */
	'app.bsky.feed.like': {
		subject: RefOf<'com.atproto.repo.strongRef'>;
		createdAt: string;
	};
	/**
	 * A declaration of a post.
	 */
	'app.bsky.feed.post': {
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		text: string;
		/**
		 * Deprecated: replaced by app.bsky.richtext.facet.
		 * @deprecated
		 */
		entities?: RefOf<'app.bsky.feed.post#entity'>[];
		facets?: RefOf<'app.bsky.richtext.facet'>[];
		reply?: RefOf<'app.bsky.feed.post#replyRef'>;
		embed?:
			| UnionOf<'app.bsky.embed.images'>
			| UnionOf<'app.bsky.embed.external'>
			| UnionOf<'app.bsky.embed.record'>
			| UnionOf<'app.bsky.embed.recordWithMedia'>;
		/**
		 * Maximum array length: 3
		 */
		langs?: string[];
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
		/**
		 * Additional non-inline tags describing this post. \
		 * Maximum array length: 8 \
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tags?: string[];
		createdAt: string;
	};
	/**
	 * A declaration of a repost.
	 */
	'app.bsky.feed.repost': {
		subject: RefOf<'com.atproto.repo.strongRef'>;
		createdAt: string;
	};
	/**
	 * Defines interaction gating rules for a thread. The rkey of the threadgate record should match the rkey of the thread's root post.
	 */
	'app.bsky.feed.threadgate': {
		post: AtUri;
		/**
		 * Maximum array length: 5
		 */
		allow?: (
			| UnionOf<'app.bsky.feed.threadgate#mentionRule'>
			| UnionOf<'app.bsky.feed.threadgate#followingRule'>
			| UnionOf<'app.bsky.feed.threadgate#listRule'>
		)[];
		createdAt: string;
	};
	/**
	 * A declaration of a block.
	 */
	'app.bsky.graph.block': {
		subject: DID;
		createdAt: string;
	};
	/**
	 * A declaration of a social follow.
	 */
	'app.bsky.graph.follow': {
		subject: DID;
		createdAt: string;
	};
	/**
	 * A declaration of a list of actors.
	 */
	'app.bsky.graph.list': {
		purpose: RefOf<'app.bsky.graph.defs#listPurpose'>;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: AtBlob<`image/png` | `image/jpeg`>;
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
		createdAt: string;
	};
	/**
	 * A block of an entire list of actors.
	 */
	'app.bsky.graph.listblock': {
		subject: AtUri;
		createdAt: string;
	};
	/**
	 * An item under a declared list of actors.
	 */
	'app.bsky.graph.listitem': {
		subject: DID;
		list: AtUri;
		createdAt: string;
	};
}
